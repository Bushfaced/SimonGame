//*********/ CONSTANTS *****************/
const colorChoices = [0, 1, 2, 3]; //this holds the array for the possible choices





//*********/ STATE VARIABLES ***********/
let levels; //this will be the variable for comparing if the userWonLevel, and 
// what level they are on, or if they lost and the game resets to level one
let intervals; //this variable will control the intervals between the lights flashing during 
// a level, and before the start of the next level. Also sets no time limit for the user
let loseCondition; //there is no win condition. You can only lose once the user clicks the wrong color in the pattern
// follow the sequence.
let playerTurn; //this compares each player click to the random sequence generated by
// the computer.
let compTurn; //this stops the user from being able to interact with the page while the
// computerPattern plays as well as initiates the turn 

//*********/ Event Listeners ***********/
document.querySelector('.colorBtns').addEventListener('click', buttonsClicked); //example event listener
// document.querySelector('');
// document.querySelector('main').addEventListener('click', handleChoice); //from class example on RPS
// ******function********* //
init();

function init() {
  const btnsClicked = compTurn.length;

}


function blinkColor() {

};

function buttonsClicked() {
  if (btnsClicked === compTurn) {
    return 'Level Won! Great memory'; 
  } else {
    return 'You lose!';
  } 
    // console.log(btnsClicked);
};

function compTurn() {

};


//********************* section of functions I could possibly use *********************//

// function blinkColor(color) { //need to make this my own, but for making the lights flash
//     let colorButton = document.getElementById(color);
//     colorButton.style.background = *highlightColor*;
//     if(highlightColor == colorButton.style.background){
//       setTimeout(() => {colorButton.style.background = *white(i.e.)*}, 1000);
//     } else {
//       setTimeout(() => {colorButton.style.background = *originalColor*}, 1000);
//     }
// };

// function getRandomRPS() { //change to getRandomColor? or getRandomPattern
//     const RPS = Object.keys(RPS_LOOKUP); //create constant like RPS_LOOKUP
//     const rndIdx = Math.floor(Math.random() * RPS.length); //re-define rndIdx to become rndColor maybe
//     return RPS[rndIdx]; //return new name for RPS and rndIdx
// };


// function renderCountdown(cb) { //possibly used to take whether user beat the level or not and display the level count to that button
//     let count = 3;
//     countdownEl.textContent = count;
//     countdownEl.style.visibility = 'visible';
//     countdownAudio.currentTime = 0;
//     countdownAudio.play();
//     const timerId = setInterval(function () {
//       count--;
//       if (count <= 0) {
//         clearInterval(timerId);
//         countdownEl.style.visibility = 'hidden';
//         cb();
//       } else {
//         countdownEl.textContent = count;
//       }
//     }, 1000);
// };


// function handleChoice(evt) { //maybe I could use this to handle to comparison of patternDisplayed to userClickedPattern?
//     if (evt.target.tagName !== 'BUTTON') return;
//     renderCountdown(function() {
//       results.p = evt.target.innerText.toLowerCase();
//       results.c = getRandomRPS();
//       if (results.p === results.c) {
//         winner = 't';
//       } else {
//         winner = RPS_LOOKUP[results.p].beats === results.c ? 'p' : 'c';
//       }
//       scores[winner]++;
//       render();
//     });
// }




// function genRandColor() { //Amar example of how to expand rounds
//   let rand = Math.random() * (3 - 0 + 1) + 0;
//   let randRound = Math.floor(rand)
//   return randRound;
// }





